package deploysrv

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/goccy/go-yaml"
	"github.com/rusq/dlog"
)

const (
	DTDockerHub DeploymentType = "dockerhub"
)

const (
	StateSuccess = "success"
	StateFailure = "failure"
	StateError   = "error"
)

func init() {
	deploymentTypes[string(DTDockerHub)] = new(DockerHub)
}

type DockerHub struct {
	mapping map[string]map[string]Deployment // deployment = mapping[repo][tag]
}

// Generated by https://quicktype.io

type DockerhubWebhook struct {
	CallbackURL string     `json:"callback_url"`
	PushData    PushData   `json:"push_data"`
	Repository  Repository `json:"repository"`
}

type PushData struct {
	Images   []string `json:"images"`
	PushedAt float64  `json:"pushed_at"`
	Pusher   string   `json:"pusher"`
	Tag      string   `json:"tag"`
}

type Repository struct {
	CommentCount    int64   `json:"comment_count"`
	DateCreated     float64 `json:"date_created"`
	Description     string  `json:"description"`
	Dockerfile      string  `json:"dockerfile"`
	FullDescription string  `json:"full_description"`
	IsOfficial      bool    `json:"is_official"`
	IsPrivate       bool    `json:"is_private"`
	IsTrusted       bool    `json:"is_trusted"`
	Name            string  `json:"name"`
	Namespace       string  `json:"namespace"`
	Owner           string  `json:"owner"`
	RepoName        string  `json:"repo_name"`
	RepoURL         string  `json:"repo_url"`
	StarCount       int64   `json:"star_count"`
	Status          string  `json:"status"`
}

type DockerHubCallback struct {
	State       string `json:"state"`
	Description string `json:"description"`
	Context     string `json:"context"`
	TargetURL   string `json:"target_url"`
}

type Docker struct {
	RepoName string   `yaml:"repo_name"`
	Tags     []string `yaml:"tags,omitempty"`
}

func (d *DockerHub) Register(dep Deployment) error {
	// ugly af
	dc, err := d.tryUnmarshal(dep.Payload)
	if err != nil {
		return err
	}
	d.add(dc, dep)

	return nil
}

const any = "*"

func (d *DockerHub) add(dc *Docker, dep Deployment) {
	if d.mapping == nil {
		d.mapping = make(map[string]map[string]Deployment)
	}
	if d.mapping[dc.RepoName] == nil {
		d.mapping[dc.RepoName] = make(map[string]Deployment)
	}
	if len(dc.Tags) == 0 {
		d.mapping[dc.RepoName][any] = dep
	}
	for _, tag := range dc.Tags {
		d.mapping[dc.RepoName][tag] = dep
	}
}

func (d *DockerHub) tryUnmarshal(I interface{}) (*Docker, error) {
	encoded, err := yaml.Marshal(I)
	if err != nil {
		return nil, err
	}
	var dc Docker
	if err := yaml.Unmarshal(encoded, &dc); err != nil {
		return nil, err
	}
	return &dc, nil
}

func (d *DockerHub) Handler(j chan<- Job) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var buf strings.Builder
		var wh DockerhubWebhook
		dec := json.NewDecoder(io.TeeReader(r.Body, &buf))
		if err := dec.Decode(&wh); err != nil {
			dlog.Printf("invalid body: %s", buf.String())
			badRequest(w)
			return
		}

		tagsDP, ok := d.mapping[wh.Repository.RepoName]
		if !ok {
			dlog.Printf("no deployment for repository: %q", wh.Repository.RepoName)
			http.Error(w, "no deployment for this repository", http.StatusNotFound)
			return
		}

		dp, ok := tagsDP[any]
		if !ok {
			dp, ok = tagsDP[wh.PushData.Tag]
			if !ok {
				dlog.Printf("[%s] no deployment for tag: %q", wh.Repository.RepoName, wh.PushData.Tag)
				http.Error(w, "no deployment for this tag", http.StatusNotFound)
				return
			}
		}

		if dp.Disabled {
			dlog.Printf("[%s] deployment for tag: %q is disabled", wh.Repository.RepoName, wh.PushData.Tag)
			http.Error(w, "deployment for this tag is disabled", http.StatusNotFound)
			return
		}

		j <- Job{Dep: dp, CallbackURL: wh.CallbackURL}

		w.WriteHeader(http.StatusOK)
		w.Write([]byte(http.StatusText(http.StatusOK)))
	}
}

func (d *DockerHub) Callback(data CallbackData) error {
	state := StateSuccess
	descr := data.Description
	if data.Error != nil {
		state = StateError
		descr = data.Error.Error()
	}
	cb := DockerHubCallback{
		State:       state,
		Description: fmt.Sprintf("[%s]: %s", data.ID, descr),
		Context:     data.Context,
		TargetURL:   data.ResultsURL,
	}
	b, err := json.Marshal(cb)
	if err != nil {
		return err
	}
	// post the results
	dlog.Printf("%s> posting results to %s", data.ID, data.CallbackURL)
	dlog.Debugf("%s> data: %s", data.ID, string(b))
	resp, err := http.Post(data.CallbackURL, "application/json", bytes.NewReader(b))
	if err != nil {
		return err
	}
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("invalid status code: %d", resp.StatusCode)
	}
	dlog.Printf("%s> post ok", data.ID)
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		dlog.Printf("%s> error reading body: %s", data.ID, err)
	}
	dlog.Debugf("%s> body: %s", data.ID, string(body))
	return nil
}
